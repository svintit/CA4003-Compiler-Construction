/*******************************
***** SECTION 1 - OPTIONS *****
*******************************/

options{
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}

/*********************************
***** SECTION 2 - USER CODE *****
*********************************/

PARSER_BEGIN(MyParser)

  public class MyParser {
    public static void main(String args[]) {
      MyParser tokeniser;
      if (args.length == 0) {
        System.out.println("Reading from standard input...");
        tokeniser = new MyParser(System.in);
      }
      else if (args.length == 1) {
        try {
          tokeniser = new MyParser(new java.io.FileInputStream(args[0]));
        }
        catch (java.io.FileNotFoundException e) {
          System.err.println("File " + args[0] + " not found.");
          return;
        }
      }
      else {
        System.out.println("MyParser: Usage is one of:");
        System.out.println("      java MyParser < inputfile");
        System.out.println("OR");
        System.out.println("      java MyParser inputfile");
        return;
      }
      try {
  			tokeniser.Program();
  			System.out.println("Parsing successful");
		  }
  		catch (ParseException e) {
  			System.out.println("Encountered errors during parsing.");
  			System.out.println(e.getMessage());
  		}
    }
  }

PARSER_END(MyParser)

/****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
****************************************/

/* DECLARE NESTING VAR */
TOKEN_MGR_DECLS : {
    static int commentNesting = 0;
}

/* SKIP WHITESPACE AND COMMENTS */
SKIP : {
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
  | "/*" { commentNesting++; } : IN_COMMENT
  | < "//" (~["\r", "\n"])* >
}

<IN_COMMENT> SKIP : {
    "/*" { commentNesting++; }
  | "*/" { commentNesting--;
           if (commentNesting == 0)
              SwitchTo(DEFAULT);
         }
  | <~[]>
}

/* RESERVED WORDS */
TOKEN : {
    < VARIABLE: "variable" >
  | < CONSTANT: "constant" >
  | < RETURN: "return" >
  | < INTEGER: "integer" >
  | < BOOLEAN: "boolean" >
  | < VOID: "void" >
  | < MAIN: "main" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < WHILE: "while" >
  | < BEGIN: "begin" >
  | < END: "end" >
  | < IS: "is" >
  | < SKIPPY: "skip" >
}

/* OPERATORS */
TOKEN : {
    < COMMA: "," >
  | < SEMICOL: ";" >
  | < COLON: ":" >
  | < ASSIGN: ":=" >
  | < L_BRACK: "(" >
  | < R_BRACK: ")" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < BITNOT: "~" >
  | < BITOR: "|" >
  | < BITAND: "&" >
  | < EQUAL: "=" >
  | < N_EQUAL: "!=" >
  | < L_THAN: "<" >
  | < L_OR_EQU: "<=" >
  | < G_THAN: ">" >
  | < G_OR_EQU: ">=" >
}

/* REGULAR EXPRESSIONS */
TOKEN : {
    < #DIGIT: ["0"-"9"] >
  | < #CHAR: ["a"-"z", "A"-"Z"] >
  | < NUM: ((<MINUS>)? ["1"-"9"] (<DIGIT>)*) | ((<MINUS>)? ["0"]) >
  | < ID: (<CHAR>) ((<DIGIT>) | (<CHAR>) | "_")* >
}

/* ANY OTHER EXPRESSION THAT EXISTS */
TOKEN : {
    < OTHER : ~[] >
}

/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/

void Program() : {} {
    DeclList() FunctionList() Main()
}

void DeclList() : {} {
    (Decl() <SEMICOL> DeclList())
  | {}
}

void Decl() : {} {
    VarDecl()
  | ConstDecl()
}

void VarDecl() : {} {
    <VARIABLE> <ID> <COLON> Type()
}

void ConstDecl() : {} {
    <CONSTANT> <ID> <COLON> Type() <ASSIGN> Expression()
}

void FunctionList() : {} {
    (Function() FunctionList())
  | {}
}

void Function() : {} {
    Type() <ID> <L_BRACK> ParameterList() <R_BRACK> <IS> DeclList()
    <BEGIN>
    StatementBlock()
    <RETURN> <L_BRACK> (Expression() | {}) <R_BRACK> <SEMICOL>
    <END>
}

void Type() : {} {
    <INTEGER>
  | <BOOLEAN>
  | <VOID>
}

void ParameterList() : {} {
    NempParameterList()
  | {}
}

void NempParameterList() : {} {
    <ID> <COLON> Type() (<COMMA> NempParameterList() | {})
}

void Main() : {} {
    <MAIN>
    <BEGIN>
    DeclList()
    StatementBlock()
    <END>
}

void StatementBlock() : {} {
    (Statement() StatementBlock())
  | {}
}

void Statement() : {} {
    <ID> (<ASSIGN> Expression() <SEMICOL> | <L_BRACK> ArgList() <R_BRACK> <SEMICOL>)
  | <BEGIN> StatementBlock() <END>
  | <IF> Condition() <BEGIN> StatementBlock() <END>
    <ELSE> <BEGIN> StatementBlock() <END>
  | <WHILE> Condition() <BEGIN> StatementBlock() <END>
  | <SKIPPY> <SEMICOL>

}

void Expression() : {} {
    Fragment() (BinaryArithOp() Fragment() | {})
}

void BinaryArithOp() : {} {
    <PLUS>
  | <MINUS>
}

void Fragment() : {} {
    <ID> (<L_BRACK> ArgList() <R_BRACK> FragmentPrime() | FragmentPrime())
  | <MINUS> <ID> FragmentPrime()
  | <NUM> FragmentPrime()
  | <TRUE> FragmentPrime()
  | <FALSE> FragmentPrime()
  | <L_BRACK> Expression() <R_BRACK> FragmentPrime()
}

void FragmentPrime() : {} {
    BinaryArithOp() Fragment() FragmentPrime()
  | {}
}

void Condition() : {} {
    <BITNOT> Condition() ConditionPrime()
  | LOOKAHEAD(3) (<L_BRACK> Condition() <R_BRACK> ConditionPrime())
  | Expression() CompOp() Expression() ConditionPrime()
}

void ConditionPrime() : {} {
    (<BITOR> | <BITAND>) Condition() ConditionPrime()
  | {}
}

void CompOp() : {} {
    <EQUAL>
  | <N_EQUAL>
  | <L_THAN>
  | <L_OR_EQU>
  | <G_THAN>
  | <G_OR_EQU>
}

void ArgList() : {} {
    NempArgList()
  | {}
}

void NempArgList() : {} {
    <ID> (<COMMA> NempArgList() | {})
}
